//===--- ASTMatchers.h - Structural query framework -------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
//  This file implements matchers to be used together with the MatchFinder to
//  match AST nodes.
//
//  Matchers are created by generator functions, which can be combined in
//  a functional in-language DSL to express queries over the C++ AST.
//
//  For example, to match a class with a certain name, one would call:
//    Class(HasName("MyClass"))
//  which returns a matcher that can be used to find all AST nodes that declare
//  a class named 'MyClass'.
//
//  For more complicated match expressions we're often interested in accessing
//  multiple parts of the matched AST nodes once a match is found. In that case,
//  use the Id(...) matcher around the match expressions that match the nodes
//  which you want to access.
//
//  For example, when we're interested in child classes of a certain class, we
//  would write:
//    Class(HasName("MyClass"), HasChild(Id("child", Class())))
//  When the match is found via the MatchFinder, a user provided callback will
//  be called with a BoundNodes instance that contains a mapping from the
//  strings that we provided for the Id(...) calls to the nodes that were
//  matched.
//  In the given example, each time our matcher finds a match we get a callback
//  where "child" is bound to the CXXRecordDecl node of the matching child
//  class declaration.
//
//  See ASTMatchersInternal.h for a more in-depth explanation of the
//  implementation details of the matcher framework.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
#define LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H

#include "clang/ASTMatchers/ASTMatchersInternal.h"
#include "clang/ASTMatchers/ASTMatchersMacros.h"
#include "llvm/ADT/Twine.h"

namespace clang {
namespace ast_matchers {

/// \brief Maps string IDs to AST nodes matched by parts of a matcher.
///
/// The bound nodes are generated by adding Id(...) matchers into the
/// match expression around the matchers for the nodes we want to access later.
///
/// The instances of BoundNodes are created by MatchFinder when the user's
/// callbacks are executed when a match is found.
class BoundNodes {
public:
  /// \brief Returns the AST node bound to 'ID'.
  /// Returns NULL if there was no node bound to 'ID' or if there is a node but
  /// it cannot be converted to the specified type.
  /// FIXME: We'll need one of those for every base type.
  /// @{
  template <typename T>
  const T *GetDeclAs(const std::string &ID) const {
    return GetNodeAs<T>(DeclBindings, ID);
  }
  template <typename T>
  const T *GetStmtAs(const std::string &ID) const {
    return GetNodeAs<T>(StmtBindings, ID);
  }
  /// @}

private:
  /// Create BoundNodes from a pre-filled map of bindings.
  BoundNodes(const std::map<std::string, const clang::Decl*> &DeclBindings,
             const std::map<std::string, const clang::Stmt*> &StmtBindings)
      : DeclBindings(DeclBindings), StmtBindings(StmtBindings) {}

  template <typename T, typename MapT>
  const T *GetNodeAs(const MapT &Bindings, const std::string &ID) const {
    typename MapT::const_iterator It = Bindings.find(ID);
    if (It == Bindings.end()) {
      return NULL;
    }
    return llvm::dyn_cast<T>(It->second);
  }

  std::map<std::string, const clang::Decl*> DeclBindings;
  std::map<std::string, const clang::Stmt*> StmtBindings;

  friend class internal::BoundNodesTree;
};

/// \brief If the provided matcher matches a node, binds the node to 'id'.
/// FIXME: Add example for accessing it.
template <typename T>
internal::Matcher<T> Id(const std::string &ID,
                        const internal::Matcher<T> &InnerMatcher) {
  return internal::Matcher<T>(new internal::IdMatcher<T>(ID, InnerMatcher));
}

/// \brief Types of matchers for the top-level classes in the AST class
/// hierarchy.
/// @{
typedef internal::Matcher<clang::Decl> DeclarationMatcher;
typedef internal::Matcher<clang::QualType> TypeMatcher;
typedef internal::Matcher<clang::Stmt> StatementMatcher;
/// @}

/// Matches any node. Useful when another matcher requires a child matcher,
/// but there's no additional constraint. This will often be used with an
/// explicit conversion to a internal::Matcher<> type such as TypeMatcher.
///
/// Example: DeclarationMatcher(True()) matches all declarations, e.g.,
/// "int* p" and "void f()" in
///   int* p;
///   void f();
inline internal::PolymorphicMatcherWithParam0<internal::TrueMatcher> True() {
  return internal::PolymorphicMatcherWithParam0<internal::TrueMatcher>();
}

/// Matches a declaration of anything that could have a name.
///
/// Example matches X, S, the anonymous union type, i, and U;
///   typedef int X;
///   struct S {
///     union {
///       int i;
///     } U;
///   };
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::NamedDecl> NameableDeclaration;

/// Matches C++ class declarations.
///
/// Example matches X, Z
///   class X;
///   template<class T> class Z {};
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::CXXRecordDecl> Class;

/// Matches C++ constructor declarations.
///
/// Example matches Foo::Foo() and Foo::Foo(int)
///   class Foo {
///    public:
///     Foo();
///     Foo(int);
///     int DoSomething();
///   };
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::CXXConstructorDecl> Constructor;

/// Matches method declarations.
///
/// Example matches y
///   class X { void y() };
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::CXXMethodDecl> Method;

/// Matches variable declarations.
///
/// Note: this does not match declarations of member variables, which are
/// "field" declarations in Clang parlance.
///
/// Example matches a
///   int a;
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::VarDecl> Variable;

/// Matches field declarations.
///
/// Given
///   class X { int m; };
/// Field()
///   matches 'm'.
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::FieldDecl> Field;

/// Matches function declarations.
///
/// Example matches f
///   void f();
const internal::VariadicDynCastAllOfMatcher<
  clang::Decl,
  clang::FunctionDecl> Function;


/// Matches statements.
///
/// Given
///   { ++a; }
/// Statement()
///   matches both the compound statement '{ ++a; }' and '++a'.
const internal::VariadicDynCastAllOfMatcher<clang::Stmt, clang::Stmt> Statement;

/// Matches declaration statements.
///
/// Given
///   int a;
/// DeclarationStatement()
///   matches 'int a'.
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::DeclStmt> DeclarationStatement;

/// Matches member expressions.
///
/// Given
///   class Y {
///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
///     int a; static int b;
///   };
/// MemberExpression()
///   matches this->x, x, y.x, a, this->b
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::MemberExpr> MemberExpression;

/// Matches call expressions.
///
/// Example matches x.y()
///   X x;
///   x.y();
const internal::VariadicDynCastAllOfMatcher<clang::Stmt, clang::CallExpr> Call;

/// Matches constructor call expressions (including implicit ones).
///
/// Example matches string(ptr, n) and ptr within arguments of f
///     (matcher = ConstructorCall())
///   void f(const string &a, const string &b);
///   char *ptr;
///   int n;
///   f(string(ptr, n), ptr);
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::CXXConstructExpr> ConstructorCall;

/// Matches nodes where temporaries are created.
///
/// Example matches FunctionTakesString(GetStringByValue())
///     (matcher = BindTemporaryExpr())
///   FunctionTakesString(GetStringByValue());
///   FunctionTakesStringByPointer(GetStringPointer());
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::CXXBindTemporaryExpr> BindTemporaryExpression;

/// Matches new expressions.
///
/// Given
///   new X;
/// NewExpression()
///   matches 'new X'.
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::CXXNewExpr> NewExpression;

/// Matches the value of a default argument at the call site.
///
/// Example matches the CXXDefaultArgExpr placeholder inserted for the
///     default value of the second parameter in the call expression f(42)
///     (matcher = DefaultArgument())
///   void f(int x, int y = 0);
///   f(42);
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::CXXDefaultArgExpr> DefaultArgument;

/// Matches overloaded operator calls.
/// Note that if an operator isn't overloaded, it won't match. Instead, use
/// BinaryOperator matcher.
/// Currently it does not match operators such as new delete.
/// FIXME: figure out why these do not match?
///
/// Example matches both operator<<((o << b), c) and operator<<(o, b)
///     (matcher = OverloadedOperatorCall())
///   ostream &operator<< (ostream &out, int i) { };
///   ostream &o; int b = 1, c = 1;
///   o << b << c;
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::CXXOperatorCallExpr> OverloadedOperatorCall;

/// Matches expressions.
///
/// Example matches x()
///   void f() { x(); }
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::Expr> Expression;

/// Matches expressions that refer to declarations.
///
/// Example matches x in if (x)
///   bool x;
///   if (x) {}
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::DeclRefExpr> DeclarationReference;

/// Matches if statements.
///
/// Example matches 'if (x) {}'
///   if (x) {}
const internal::VariadicDynCastAllOfMatcher<clang::Stmt, clang::IfStmt> If;

/// Matches for statements.
///
/// Example matches 'for (;;) {}'
///   for (;;) {}
const internal::VariadicDynCastAllOfMatcher<clang::Stmt, clang::ForStmt> For;

/// Matches while statements.
///
/// Given
///   while (true) {}
/// While()
///   matches 'while (true) {}'.
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::WhileStmt> While;

/// Matches do statements.
///
/// Given
///   do {} while (true);
/// Do()
///   matches 'do {} while(true)'
const internal::VariadicDynCastAllOfMatcher<clang::Stmt, clang::DoStmt> Do;

/// Matches case and default statements inside switch statements.
///
/// Given
///   switch(a) { case 42: break; default: break; }
/// SwitchCase()
///   matches 'case 42: break;' and 'default: break;'.
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::SwitchCase> SwitchCase;

/// Matches compound statements.
///
/// Example matches '{}' and '{{}}'in 'for (;;) {{}}'
///   for (;;) {{}}
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::CompoundStmt> CompoundStatement;

/// Matches bool literals.
///
/// Example matches true
///   true
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CXXBoolLiteralExpr> BoolLiteral;

/// Matches string literals (also matches wide string literals).
///
/// Example matches "abcd", L"abcd"
///   char *s = "abcd"; wchar_t *ws = L"abcd"
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::StringLiteral> StringLiteral;

/// Matches character literals (also matches wchar_t).
/// Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),
/// though.
///
/// Example matches 'a', L'a'
///   char ch = 'a'; wchar_t chw = L'a';
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CharacterLiteral> CharacterLiteral;

/// Matches integer literals of all sizes / encodings.
/// Not matching character-encoded integers such as L'a'.
///
/// Example matches 1, 1L, 0x1, 1U
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::IntegerLiteral> IntegerLiteral;

/// Matches binary operator expressions.
///
/// Example matches a || b
///   !(a || b)
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::BinaryOperator> BinaryOperator;

/// Matches unary operator expressions.
///
/// Example matches !a
///   !a || b
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::UnaryOperator> UnaryOperator;

/// Matches conditional operator expressions.
///
/// Example matches a ? b : c
///   (a ? b : c) + 42
const internal::VariadicDynCastAllOfMatcher<
  clang::Stmt,
  clang::ConditionalOperator> ConditionalOperator;

/// Matches a reinterpret_cast expression.
///
/// Either the source expression or the destination type can be matched
/// using Has(), but HasDestinationType() is more specific and can be
/// more readable.
///
/// Example matches reinterpret_cast<char*>(&p) in
///   void* p = reinterpret_cast<char*>(&p);
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CXXReinterpretCastExpr> ReinterpretCast;

/// Matches a C++ static_cast expression.
///
/// \see HasDestinationType
/// \see ReinterpretCast
///
/// Example:
///   StaticCast()
/// matches
///   static_cast<long>(8)
/// in
///   long eight(static_cast<long>(8));
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CXXStaticCastExpr> StaticCast;

/// Matches a dynamic_cast expression.
///
/// Example:
///   DynamicCast()
/// matches
///   dynamic_cast<D*>(&b);
/// in
///   struct B { virtual ~B() {} }; struct D : B {};
///   B b;
///   D* p = dynamic_cast<D*>(&b);
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CXXDynamicCastExpr> DynamicCast;

/// Matches a const_cast expression.
///
/// Example: Matches const_cast<int*>(&r) in
///   int n = 42;
///   const int& r(n);
///   int* p = const_cast<int*>(&r);
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CXXConstCastExpr> ConstCast;

/// Matches any cast expression written in user code, whether it be a
/// C-style cast, a functional-style cast, or a keyword cast.
///
/// Does not match implicit conversions.
///
/// Note: the name "ExplicitCast" is chosen to match Clang's terminology, as
/// Clang uses the term "cast" to apply to implicit conversions as well as to
/// actual cast expressions.
///
/// See also: HasDestinationType.
///
/// Example: matches all five of the casts in
///   int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42)))))
/// but does not match the implicit conversion in
///   long ell = 42;
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::ExplicitCastExpr> ExplicitCast;

/// Matches the implicit cast nodes of Clang's AST.
///
/// This matches many different places, including function call return value
/// eliding, as well as any type conversions.
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::ImplicitCastExpr> ImplicitCast;

/// Matches functional cast expressions
///
/// Example: Matches Foo(bar);
///   Foo f = bar;
///   Foo g = (Foo) bar;
///   Foo h = Foo(bar);
const internal::VariadicDynCastAllOfMatcher<
  clang::Expr,
  clang::CXXFunctionalCastExpr> FunctionalCast;

/// \brief Various overloads for the AnyOf matcher.
/// @{
template<typename C1, typename C2>
internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C1, C2>
AnyOf(const C1 &P1, const C2 &P2) {
  return internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher,
                                                C1, C2 >(P1, P2);
}
template<typename C1, typename C2, typename C3>
internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C1,
    internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C2, C3> >
AnyOf(const C1 &P1, const C2 &P2, const C3 &P3) {
  return AnyOf(P1, AnyOf(P2, P3));
}
template<typename C1, typename C2, typename C3, typename C4>
internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C1,
    internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C2,
        internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher,
                                               C3, C4> > >
AnyOf(const C1 &P1, const C2 &P2, const C3 &P3, const C4 &P4) {
  return AnyOf(P1, AnyOf(P2, AnyOf(P3, P4)));
}
template<typename C1, typename C2, typename C3, typename C4, typename C5>
internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C1,
    internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C2,
        internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher, C3,
            internal::PolymorphicMatcherWithParam2<internal::AnyOfMatcher,
                                                   C4, C5> > > >
AnyOf(const C1& P1, const C2& P2, const C3& P3, const C4& P4, const C5& P5) {
  return AnyOf(P1, AnyOf(P2, AnyOf(P3, AnyOf(P4, P5))));
}
/// @}

/// \brief Various overloads for the AllOf matcher.
/// @{
template<typename C1, typename C2>
internal::PolymorphicMatcherWithParam2<internal::AllOfMatcher, C1, C2>
AllOf(const C1 &P1, const C2 &P2) {
  return internal::PolymorphicMatcherWithParam2<internal::AllOfMatcher,
                                                C1, C2>(P1, P2);
}
template<typename C1, typename C2, typename C3>
internal::PolymorphicMatcherWithParam2<internal::AllOfMatcher, C1,
    internal::PolymorphicMatcherWithParam2<internal::AllOfMatcher, C2, C3> >
AllOf(const C1& P1, const C2& P2, const C3& P3) {
  return AllOf(P1, AllOf(P2, P3));
}
/// @}

/// Matches NamedDecl nodes that have the specified name. Supports specifying
/// enclosing namespaces or classes by prefixing the name with '<enclosing>::'.
/// Does not match typedefs of an underlying type with the given name.
///
/// Example matches X (name == "X")
///   class X;
///
/// Example matches X (name is one of "::a::b::X", "a::b::X", "b::X", "X")
/// namespace a { namespace b { class X; } }
AST_MATCHER_P(clang::NamedDecl, HasName, std::string, Name) {
  assert(!Name.empty());
  const std::string FullNameString = "::" + Node.getQualifiedNameAsString();
  const llvm::StringRef FullName = FullNameString;
  const llvm::StringRef Pattern = Name;
  if (Pattern.startswith("::")) {
    return FullName == Pattern;
  } else {
    return FullName.endswith(("::" + Pattern).str());
  }
}

/// Matches overloaded operator name given in strings without the "operator"
/// prefix, such as "<<", for OverloadedOperatorCall's.
///
/// Example matches a << b
///     (matcher == OverloadedOperatorCall(HasOverloadedOperatorName("<<")))
///   a << b;
///   c && d;  // assuming both operator<<
///            // and operator&& are overloaded somewhere.
AST_MATCHER_P(clang::CXXOperatorCallExpr,
              HasOverloadedOperatorName, std::string, Name) {
  return clang::getOperatorSpelling(Node.getOperator()) == Name;
}

/// Matches C++ classes that are directly or indirectly derived from
/// the given base class. Note that a class is considered to be also
/// derived from itself. The parameter specified the name of the base
/// type (either a class or a typedef), and does not allow structural
/// matches for namespaces or template type parameters.
///
/// Example matches X, Y, Z, C (base == "X")
///   class X;                // A class is considered to be derived from itself.
///   class Y : public X {};  // directly derived
///   class Z : public Y {};  // indirectly derived
///   typedef X A;
///   typedef A B;
///   class C : public B {};  // derived from a typedef of X
///
/// In the following example, Bar matches IsDerivedFrom("X"):
///   class Foo;
///   typedef Foo X;
///   class Bar : public Foo {};  // derived from a type that X is a typedef of
AST_MATCHER_P(clang::CXXRecordDecl, IsDerivedFrom, std::string, Base) {
  assert(!Base.empty());
  return Finder->ClassIsDerivedFrom(&Node, Base);
}

/// Matches AST nodes that have child AST nodes that match the provided matcher.
///
/// Example matches X, Y (matcher = Class(Has(Class(HasName("X")))
///   class X {};  // Matches X, because X::X is a class of name X inside X.
///   class Y { class X {}; };
///   class Z { class Y { class X {}; }; };  // Does not match Z.
///
/// ChildT must be an AST base type.
template <typename ChildT>
internal::ArgumentAdaptingMatcher<internal::HasMatcher, ChildT> Has(
    const internal::Matcher<ChildT> &ChildMatcher) {
  return internal::ArgumentAdaptingMatcher<internal::HasMatcher,
                                           ChildT>(ChildMatcher);
}

/// Matches AST nodes that have descendant AST nodes that match the provided
/// matcher.
///
/// Example matches X, Y, Z
///     (matcher = Class(HasDescendant(Class(HasName("X")))))
///   class X {};  // Matches X, because X::X is a class of name X inside X.
///   class Y { class X {}; };
///   class Z { class Y { class X {}; }; };
///
/// DescendantT must be an AST base type.
template <typename DescendantT>
internal::ArgumentAdaptingMatcher<internal::HasDescendantMatcher, DescendantT>
HasDescendant(const internal::Matcher<DescendantT> &DescendantMatcher) {
  return internal::ArgumentAdaptingMatcher<
    internal::HasDescendantMatcher,
    DescendantT>(DescendantMatcher);
}


/// Matches AST nodes that have child AST nodes that match the provided matcher.
///
/// Example matches X, Y (matcher = Class(ForEach(Class(HasName("X")))
///   class X {};  // Matches X, because X::X is a class of name X inside X.
///   class Y { class X {}; };
///   class Z { class Y { class X {}; }; };  // Does not match Z.
///
/// ChildT must be an AST base type.
///
/// As opposed to 'Has', 'ForEach' will cause a match for each result that
/// matches instead of only on the first one.
template <typename ChildT>
internal::ArgumentAdaptingMatcher<internal::ForEachMatcher, ChildT> ForEach(
    const internal::Matcher<ChildT>& ChildMatcher) {
  return internal::ArgumentAdaptingMatcher<
    internal::ForEachMatcher,
    ChildT>(ChildMatcher);
}

/// Matches AST nodes that have descendant AST nodes that match the provided
/// matcher.
///
/// Example matches X, A, B, C
///     (matcher = Class(ForEachDescendant(Class(HasName("X")))))
///   class X {};  // Matches X, because X::X is a class of name X inside X.
///   class A { class X {}; };
///   class B { class C { class X {}; }; };
///
/// DescendantT must be an AST base type.
///
/// As opposed to 'HasDescendant', 'ForEachDescendant' will cause a match for
/// each result that matches instead of only on the first one.
///
/// Note: Recursively combined ForEachDescendant can cause many matches:
///   Class(ForEachDescendant(Class(ForEachDescendant(Class()))))
/// will match 10 times (plus injected class name matches) on:
///   class A { class B { class C { class D { class E {}; }; }; }; };
template <typename DescendantT>
internal::ArgumentAdaptingMatcher<internal::ForEachDescendantMatcher, DescendantT>
ForEachDescendant(
    const internal::Matcher<DescendantT>& DescendantMatcher) {
  return internal::ArgumentAdaptingMatcher<
    internal::ForEachDescendantMatcher,
    DescendantT>(DescendantMatcher);
}

/// Matches if the provided matcher does not match.
///
/// Example matches Y (matcher = Class(Not(HasName("X"))))
///   class X {};
///   class Y {};
template <typename M>
internal::PolymorphicMatcherWithParam1<internal::NotMatcher, M> Not(const M &InnerMatcher) {
  return internal::PolymorphicMatcherWithParam1<
    internal::NotMatcher, M>(InnerMatcher);
}

/// Matches a type if the declaration of the type matches the given matcher.
inline internal::PolymorphicMatcherWithParam1< internal::HasDeclarationMatcher,
                                     internal::Matcher<clang::Decl> >
    HasDeclaration(const internal::Matcher<clang::Decl> &InnerMatcher) {
  return internal::PolymorphicMatcherWithParam1<
    internal::HasDeclarationMatcher,
    internal::Matcher<clang::Decl> >(InnerMatcher);
}

/// Matches on the implicit object argument of a member call expression.
///
/// Example matches y.x() (matcher = Call(On(HasType(Class(HasName("Y"))))))
///   class Y { public: void x(); };
///   void z() { Y y; y.x(); }",
///
/// FIXME: Overload to allow directly matching types?
AST_MATCHER_P(clang::CXXMemberCallExpr, On, internal::Matcher<clang::Expr>,
              InnerMatcher) {
  const clang::Expr *ExprNode = const_cast<clang::CXXMemberCallExpr&>(Node)
      .getImplicitObjectArgument()
      ->IgnoreParenImpCasts();
  return (ExprNode != NULL &&
          InnerMatcher.Matches(*ExprNode, Finder, Builder));
}

/// Matches if the call expression's callee expression matches.
///
/// Given
///   class Y { void x() { this->x(); x(); Y y; y.x(); } };
///   void f() { f(); }
/// Call(Callee(Expression()))
///   matches this->x(), x(), y.x(), f()
/// with Callee(...)
///   matching this->x, x, y.x, f respectively
///
/// Note: Callee cannot take the more general internal::Matcher<clang::Expr> because
/// this introduces ambiguous overloads with calls to Callee taking a
/// internal::Matcher<clang::Decl>, as the matcher hierarchy is purely implemented in
/// terms of implicit casts.
AST_MATCHER_P(clang::CallExpr, Callee, internal::Matcher<clang::Stmt>,
              InnerMatcher) {
  const clang::Expr *ExprNode = Node.getCallee();
  return (ExprNode != NULL &&
          InnerMatcher.Matches(*ExprNode, Finder, Builder));
}

/// Matches if the call expression's callee's declaration matches the given
/// matcher.
///
/// Example matches y.x() (matcher = Call(Callee(Method(HasName("x")))))
///   class Y { public: void x(); };
///   void z() { Y y; y.x();
inline internal::Matcher<clang::CallExpr> Callee(
    const internal::Matcher<clang::Decl> &InnerMatcher) {
  return internal::Matcher<clang::CallExpr>(HasDeclaration(InnerMatcher));
}

/// Matches if the expression's or declaration's type matches a type matcher.
///
/// Example matches x (matcher = Expression(HasType(
///                        HasDeclaration(Class(HasName("X"))))))
///             and z (matcher = Variable(HasType(
///                        HasDeclaration(Class(HasName("X"))))))
///  class X {};
///  void y(X &x) { x; X z; }
AST_POLYMORPHIC_MATCHER_P(HasType, internal::Matcher<clang::QualType>,
                          InnerMatcher) {
  TOOLING_COMPILE_ASSERT((llvm::is_base_of<clang::Expr, NodeType>::value ||
                          llvm::is_base_of<clang::ValueDecl, NodeType>::value),
                         instantiated_with_wrong_types);
  return InnerMatcher.Matches(Node.getType(), Finder, Builder);
}

/// Overloaded to match the declaration of the expression's or value
/// declaration's type.
/// In case of a value declaration (for example a variable declaration),
/// this resolves one layer of indirection. For example, in the value
/// declaration "X x;", Class(HasName("X")) matches the declaration of X,
/// while Variable(HasType(Class(HasName("X")))) matches the declaration
/// of x."
///
/// Example matches x (matcher = Expression(HasType(Class(HasName("X")))))
///             and z (matcher = Variable(HasType(Class(HasName("X")))))
///  class X {};
///  void y(X &x) { x; X z; }
inline internal::PolymorphicMatcherWithParam1<
  internal::matcher_HasTypeMatcher,
  internal::Matcher<clang::QualType> >
HasType(const internal::Matcher<clang::Decl> &InnerMatcher) {
  return HasType(internal::Matcher<clang::QualType>(
    HasDeclaration(InnerMatcher)));
}

/// Matches if the matched type is a pointer type and the pointee type matches
/// the specified matcher.
///
/// Example matches y->x()
///     (matcher = Call(On(HasType(PointsTo(Class(HasName("Y")))))))
///   class Y { public: void x(); };
///   void z() { Y *y; y->x(); }
AST_MATCHER_P(
    clang::QualType, PointsTo, internal::Matcher<clang::QualType>,
    InnerMatcher) {
  return (Node->isPointerType() &&
          InnerMatcher.Matches(Node->getPointeeType(), Finder, Builder));
}

/// Overloaded to match the pointee type's declaration.
inline internal::Matcher<clang::QualType> PointsTo(
    const internal::Matcher<clang::Decl> &InnerMatcher) {
  return PointsTo(internal::Matcher<clang::QualType>(
    HasDeclaration(InnerMatcher)));
}

/// Matches if the matched type is a reference type and the referenced type
/// matches the specified matcher.
///
/// Example matches X &x and const X &y
///     (matcher = Variable(HasType(References(Class(HasName("X"))))))
///   class X {
///     void a(X b) {
///       X &x = b;
///       const X &y = b;
///   };
AST_MATCHER_P(clang::QualType, References, internal::Matcher<clang::QualType>,
              InnerMatcher) {
  return (Node->isReferenceType() &&
          InnerMatcher.Matches(Node->getPointeeType(), Finder, Builder));
}

/// Overloaded to match the referenced type's declaration.
inline internal::Matcher<clang::QualType> References(
    const internal::Matcher<clang::Decl> &InnerMatcher) {
  return References(internal::Matcher<clang::QualType>(
    HasDeclaration(InnerMatcher)));
}

AST_MATCHER_P(clang::CXXMemberCallExpr, OnImplicitObjectArgument,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  const clang::Expr *ExprNode =
      const_cast<clang::CXXMemberCallExpr&>(Node).getImplicitObjectArgument();
  return (ExprNode != NULL &&
          InnerMatcher.Matches(*ExprNode, Finder, Builder));
}

/// Matches if the expression's type either matches the specified matcher, or
/// is a pointer to a type that matches the InnerMatcher.
inline internal::Matcher<clang::CallExpr> ThisPointerType(
    const internal::Matcher<clang::QualType> &InnerMatcher) {
  return OnImplicitObjectArgument(
      AnyOf(HasType(InnerMatcher), HasType(PointsTo(InnerMatcher))));
}

/// Overloaded to match the type's declaration.
inline internal::Matcher<clang::CallExpr> ThisPointerType(
    const internal::Matcher<clang::Decl> &InnerMatcher) {
  return OnImplicitObjectArgument(
      AnyOf(HasType(InnerMatcher), HasType(PointsTo(InnerMatcher))));
}

/// Matches a DeclRefExpr that refers to a declaration that matches the
/// specified matcher.
///
/// Example matches x in if(x)
///     (matcher = DeclarationReference(To(Variable(HasName("x")))))
///   bool x;
///   if (x) {}
AST_MATCHER_P(clang::DeclRefExpr, To, internal::Matcher<clang::Decl>,
              InnerMatcher) {
  const clang::Decl *DeclNode = Node.getDecl();
  return (DeclNode != NULL &&
          InnerMatcher.Matches(*DeclNode, Finder, Builder));
}

/// Matches a variable declaration that has an initializer expression that
/// matches the given matcher.
///
/// Example matches x (matcher = Variable(HasInitializer(Call())))
///   bool y() { return true; }
///   bool x = y();
AST_MATCHER_P(
    clang::VarDecl, HasInitializer, internal::Matcher<clang::Expr>,
    InnerMatcher) {
  const clang::Expr *Initializer = Node.getAnyInitializer();
  return (Initializer != NULL &&
          InnerMatcher.Matches(*Initializer, Finder, Builder));
}

/// Checks that a call expression or a constructor call expression has
/// a specific number of arguments (including absent default arguments).
///
/// Example matches f(0, 0) (matcher = Call(ArgumentCountIs(2)))
///   void f(int x, int y);
///   f(0, 0);
AST_POLYMORPHIC_MATCHER_P(ArgumentCountIs, unsigned, N) {
  TOOLING_COMPILE_ASSERT((llvm::is_base_of<clang::CallExpr, NodeType>::value ||
                          llvm::is_base_of<clang::CXXConstructExpr,
                                           NodeType>::value),
                         instantiated_with_wrong_types);
  return Node.getNumArgs() == N;
}

/// Checks that a new expression has a specific number of constructor
/// arguments (including absent default arguments).
///
/// Given
///   new X(1, 2);
/// NewExpression(ConstructorArgumentCountIs(2))
///   matches 'new X(1, 2)'.
AST_MATCHER_P(clang::CXXNewExpr, ConstructorArgumentCountIs, unsigned, N) {
  return Node.getNumConstructorArgs() == N;
}

/// Matches the n'th argument of a call expression or a constructor
/// call expression.
///
/// Example matches y in x(y)
///     (matcher = Call(HasArgument(0, DeclarationReference())))
///   void x(int) { int y; x(y); }
AST_POLYMORPHIC_MATCHER_P2(
    HasArgument, unsigned, N, internal::Matcher<clang::Expr>, InnerMatcher) {
  TOOLING_COMPILE_ASSERT((llvm::is_base_of<clang::CallExpr, NodeType>::value ||
                         llvm::is_base_of<clang::CXXConstructExpr,
                                          NodeType>::value),
                         instantiated_with_wrong_types);
  return (N < Node.getNumArgs() &&
          InnerMatcher.Matches(
              *Node.getArg(N)->IgnoreParenImpCasts(), Finder, Builder));
}

/// Matches the n'th constructor argument of new expression.
///
/// Given
///   int x;
///   new X(1, y);
/// NewExpression(HasConstructorArgument(1, DeclarationReference()))
///   matches 'new X(1, y)',
/// with DeclarationReference()
///   matching 'y'.
AST_MATCHER_P2(
    clang::CXXNewExpr, HasConstructorArgument, unsigned, N,
    internal::Matcher<clang::Expr>, InnerMatcher) {
  return (N < Node.getNumConstructorArgs() &&
          InnerMatcher.Matches(
              *Node.getConstructorArg(N)->IgnoreParenImpCasts(),
              Finder, Builder));
}

/// Matches a constructor initializer.
///
/// Given
///   struct Foo {
///     Foo() : foo_(1) { }
///     int foo_;
///   };
/// Class(Has(Constructor(HasAnyConstructorInitializer(True()))))
///   Class matches Foo, HasAnyConstructorInitializer matches foo_(1)
AST_MATCHER_P(clang::CXXConstructorDecl, HasAnyConstructorInitializer,
              internal::Matcher<clang::CXXCtorInitializer>, InnerMatcher) {
  for (clang::CXXConstructorDecl::init_const_iterator I = Node.init_begin();
       I != Node.init_end(); ++I) {
    if (InnerMatcher.Matches(**I, Finder, Builder)) {
      return true;
    }
  }
  return false;
}

/// Matches the field declaration of a constructor initializer.
///
/// Given
///   struct Foo {
///     Foo() : foo_(1) { }
///     int foo_;
///   };
/// Class(Has(Constructor(HasAnyConstructorInitializer(
///     ForField(HasName("foo_"))))))
///   matches Foo
/// with ForField matching foo_
AST_MATCHER_P(clang::CXXCtorInitializer, ForField,
              internal::Matcher<clang::FieldDecl>, InnerMatcher) {
  const clang::FieldDecl *NodeAsDecl = Node.getMember();
  return (NodeAsDecl != NULL &&
      InnerMatcher.Matches(*NodeAsDecl, Finder, Builder));
}

/// Matches the initializer expression of a constructor initializer.
///
/// Given
///   struct Foo {
///     Foo() : foo_(1) { }
///     int foo_;
///   };
/// Class(Has(Constructor(HasAnyConstructorInitializer(
///     WithInitializer(IntegerLiteral(Equals(1)))))))
///   matches Foo
/// with WithInitializer matching (1)
AST_MATCHER_P(clang::CXXCtorInitializer, WithInitializer,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  const clang::Expr* NodeAsExpr = Node.getInit();
  return (NodeAsExpr != NULL &&
      InnerMatcher.Matches(*NodeAsExpr, Finder, Builder));
}

/// Matches a contructor initializer if it is explicitly written in code (as
/// opposed to implicitly added by the compiler).
///
/// Given
///   struct Foo {
///     Foo() { }
///     Foo(int) : foo_("A") { }
///     string foo_;
///   };
/// Constructor(HasAnyConstructorInitializer(IsWritten()))
///   will match Foo(int), but not Foo()
AST_MATCHER(clang::CXXCtorInitializer, IsWritten) {
  return Node.isWritten();
}

/// Matches a constructor declaration that has been implicitly added by the
/// compiler (eg. implicit default/copy constructors).
AST_MATCHER(clang::CXXConstructorDecl, IsImplicit) {
  return Node.isImplicit();
}

/// Matches any argument of a call expression or a constructor call expression.
///
/// Given
///   void x(int, int, int) { int y; x(1, y, 42); }
/// Call(HasAnyArgument(DeclarationReference()))
///   matches x(1, y, 42)
/// with HasAnyArgument(...)
///   matching y
AST_POLYMORPHIC_MATCHER_P(HasAnyArgument, internal::Matcher<clang::Expr>,
                          InnerMatcher) {
  TOOLING_COMPILE_ASSERT((llvm::is_base_of<clang::CallExpr, NodeType>::value ||
                         llvm::is_base_of<clang::CXXConstructExpr,
                                          NodeType>::value),
                         instantiated_with_wrong_types);
  for (unsigned I = 0; I < Node.getNumArgs(); ++I) {
    if (InnerMatcher.Matches(*Node.getArg(I)->IgnoreParenImpCasts(),
                             Finder, Builder)) {
      return true;
    }
  }
  return false;
}

/// Matches the n'th parameter of a function declaration.
///
/// Given
///   class X { void f(int x) {} };
/// Method(HasParameter(0, HasType(Variable())))
///   matches f(int x) {}
/// with HasParameter(...)
///   matching int x
AST_MATCHER_P2(clang::FunctionDecl, HasParameter,
               unsigned, N, internal::Matcher<clang::ParmVarDecl>,
               InnerMatcher) {
  return (N < Node.getNumParams() &&
          InnerMatcher.Matches(
              *Node.getParamDecl(N), Finder, Builder));
}

/// Matches any parameter of a function declaration.
/// Does not match the 'this' parameter of a method.
///
/// Given
///   class X { void f(int x, int y, int z) {} };
/// Method(HasAnyParameter(HasName("y")))
///   matches f(int x, int y, int z) {}
/// with HasAnyParameter(...)
///   matching int y
AST_MATCHER_P(clang::FunctionDecl, HasAnyParameter,
              internal::Matcher<clang::ParmVarDecl>, InnerMatcher) {
  for (unsigned I = 0; I < Node.getNumParams(); ++I) {
    if (InnerMatcher.Matches(*Node.getParamDecl(I), Finder, Builder)) {
      return true;
    }
  }
  return false;
}

/// Matches the condition expression of an if statement or conditional operator.
///
/// Example matches true (matcher = HasCondition(BoolLiteral(Equals(true))))
///   if (true) {}
AST_POLYMORPHIC_MATCHER_P(HasCondition, internal::Matcher<clang::Expr>,
                          InnerMatcher) {
  TOOLING_COMPILE_ASSERT(
    (llvm::is_base_of<clang::IfStmt, NodeType>::value) ||
    (llvm::is_base_of<clang::ConditionalOperator, NodeType>::value),
    has_condition_requires_if_statement_or_conditional_operator);
  const clang::Expr *const Condition = Node.getCond();
  return (Condition != NULL &&
          InnerMatcher.Matches(*Condition, Finder, Builder));
}

/// Matches the condition variable statement in an if statement.
///
/// Given
///   if (A* a = GetAPointer()) {}
/// HasConditionVariableStatment(...)
///   matches 'A* a = GetAPointer()'.
AST_MATCHER_P(clang::IfStmt, HasConditionVariableStatement,
              internal::Matcher<clang::DeclStmt>, InnerMatcher) {
  const clang::DeclStmt* const DeclarationStatement =
    Node.getConditionVariableDeclStmt();
  return DeclarationStatement != NULL &&
         InnerMatcher.Matches(*DeclarationStatement, Finder, Builder);
}

/// Matches a 'for' statement that has a given body.
///
/// Given
///   for (;;) {}
/// HasBody(CompoundStatement())
///   matches 'for (;;) {}'
/// with CompoundStatement()
///   matching '{}'
AST_MATCHER_P(clang::ForStmt, HasBody, internal::Matcher<clang::Stmt>,
              InnerMatcher) {
  const clang::Stmt *const Statement = Node.getBody();
  return (Statement != NULL &&
          InnerMatcher.Matches(*Statement, Finder, Builder));
}

/// Matches compound statements where at least one substatement matches a
/// given matcher.
///
/// Given
///   { {}; 1+2; }
/// HasAnySubstatement(CompoundStatement())
///   matches '{ {}; 1+2; }'
/// with CompoundStatement()
///   matching '{}'
AST_MATCHER_P(clang::CompoundStmt, HasAnySubstatement,
              internal::Matcher<clang::Stmt>, InnerMatcher) {
  for (clang::CompoundStmt::const_body_iterator It = Node.body_begin();
       It != Node.body_end();
       ++It) {
    if (InnerMatcher.Matches(**It, Finder, Builder)) return true;
  }
  return false;
}

/// Checks that a compound statement contains a specific number of child
/// statements.
///
/// Example: Given
///   { for (;;) {} }
/// CompoundStatement(StatementCountIs(0)))
///   matches '{}'
///   but does not match the outer compound statement.
AST_MATCHER_P(clang::CompoundStmt, StatementCountIs, unsigned, N) {
  return Node.size() == N;
}

/// Matches literals that are equal to the given value.
///
/// Example matches true (matcher = BoolLiteral(Equals(true)))
///   true
template <typename ValueT>
internal::PolymorphicMatcherWithParam1<internal::ValueEqualsMatcher, ValueT>
Equals(const ValueT &Value) {
  return internal::PolymorphicMatcherWithParam1<
    internal::ValueEqualsMatcher,
    ValueT>(Value);
}

/// Matches the operator Name of operator expressions (binary or unary).
///
/// Example matches a || b (matcher = BinaryOperator(HasOperatorName("||")))
///   !(a || b)
AST_POLYMORPHIC_MATCHER_P(HasOperatorName, std::string, Name) {
  TOOLING_COMPILE_ASSERT(
    (llvm::is_base_of<clang::BinaryOperator, NodeType>::value) ||
    (llvm::is_base_of<clang::UnaryOperator, NodeType>::value),
    has_condition_requires_if_statement_or_conditional_operator);
  return Name == Node.getOpcodeStr(Node.getOpcode());
}

/// Matches the left hand side of binary operator expressions.
///
/// Example matches a (matcher = BinaryOperator(HasLHS()))
///   a || b
AST_MATCHER_P(clang::BinaryOperator, HasLHS,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  clang::Expr *LeftHandSide = Node.getLHS();
  return (LeftHandSide != NULL &&
          InnerMatcher.Matches(*LeftHandSide, Finder, Builder));
}

/// Matches the right hand side of binary operator expressions.
///
/// Example matches b (matcher = BinaryOperator(HasRHS()))
///   a || b
AST_MATCHER_P(clang::BinaryOperator, HasRHS,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  clang::Expr *RightHandSide = Node.getRHS();
  return (RightHandSide != NULL &&
          InnerMatcher.Matches(*RightHandSide, Finder, Builder));
}

/// Matches if either the left hand side or the right hand side of a binary
/// operator matches.
inline internal::Matcher<clang::BinaryOperator> HasEitherOperand(
    const internal::Matcher<clang::Expr> &InnerMatcher) {
  return AnyOf(HasLHS(InnerMatcher), HasRHS(InnerMatcher));
}

/// Matches if the operand of a unary operator matches.
///
/// Example matches true (matcher = HasOperand(BoolLiteral(Equals(true))))
///   !true
AST_MATCHER_P(clang::UnaryOperator, HasUnaryOperand,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  const clang::Expr * const Operand = Node.getSubExpr();
  return (Operand != NULL &&
          InnerMatcher.Matches(*Operand, Finder, Builder));
}

/// Matches if the implicit cast's source expression matches the given matcher.
///
/// Example: matches "a string" (matcher =
///                                  HasSourceExpression(ConstructorCall()))
///
/// class URL { URL(string); };
/// URL url = "a string";
AST_MATCHER_P(clang::ImplicitCastExpr, HasSourceExpression,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  const clang::Expr* const SubExpression = Node.getSubExpr();
  return (SubExpression != NULL &&
          InnerMatcher.Matches(*SubExpression, Finder, Builder));
}

/// Matches casts whose destination type matches a given matcher.
///
/// (Note: Clang's AST refers to other conversions as "casts" too, and calls
/// actual casts "explicit" casts.)
AST_MATCHER_P(clang::ExplicitCastExpr, HasDestinationType,
              internal::Matcher<clang::QualType>, InnerMatcher) {
  const clang::QualType NodeType = Node.getTypeAsWritten();
  return InnerMatcher.Matches(NodeType, Finder, Builder);
}

/// Matches implicit casts whose destination type matches a given matcher.
/// FIXME: Unit test this matcher
AST_MATCHER_P(clang::ImplicitCastExpr, HasImplicitDestinationType,
              internal::Matcher<clang::QualType>, InnerMatcher) {
  return InnerMatcher.Matches(Node.getType(), Finder, Builder);
}

/// Matches the true branch expression of a conditional operator.
///
/// Example matches a
///   condition ? a : b
AST_MATCHER_P(clang::ConditionalOperator, HasTrueExpression,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  clang::Expr *Expression = Node.getTrueExpr();
  return (Expression != NULL &&
          InnerMatcher.Matches(*Expression, Finder, Builder));
}

/// Matches the false branch expression of a conditional operator.
///
/// Example matches b
///   condition ? a : b
AST_MATCHER_P(clang::ConditionalOperator, HasFalseExpression,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  clang::Expr *Expression = Node.getFalseExpr();
  return (Expression != NULL &&
          InnerMatcher.Matches(*Expression, Finder, Builder));
}

/// Matches if a declaration has a body attached.
///
/// Example matches A, va, fa
///   class A {};
///   class B;  // Doesn't match, as it has no body.
///   int va;
///   extern int vb;  // Doesn't match, as it doesn't define the variable.
///   void fa() {}
///   void fb();  // Doesn't match, as it has no body.
inline internal::PolymorphicMatcherWithParam0<internal::IsDefinitionMatcher>
IsDefinition() {
  return internal::PolymorphicMatcherWithParam0<
    internal::IsDefinitionMatcher>();
}

/// Matches the class declaration that the given method declaration belongs to.
/// TODO(qrczak): Generalize this for other kinds of declarations.
/// FIXME: What other kind of declarations would we need to generalize
/// this to?
///
/// Example matches A() in the last line
///     (matcher = ConstructorCall(HasDeclaration(Method(
///         OfClass(HasName("A"))))))
///   class A {
///    public:
///     A();
///   };
///   A a = A();
AST_MATCHER_P(clang::CXXMethodDecl, OfClass,
              internal::Matcher<clang::CXXRecordDecl>, InnerMatcher) {
  const clang::CXXRecordDecl *Parent = Node.getParent();
  return (Parent != NULL &&
          InnerMatcher.Matches(*Parent, Finder, Builder));
}

/// Matches member expressions that are called with '->' as opposed to '.'.
/// Member calls on the implicit this pointer match as called with '->'.
///
/// Given
///   class Y {
///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }
///     int a;
///     static int b;
///   };
/// MemberExpression(IsArrow())
///   matches this->x, x, y.x, a, this->b
inline internal::Matcher<clang::MemberExpr> IsArrow() {
  return MakeMatcher(new internal::IsArrowMatcher());
}

/// Matches clang::QualType nodes that are const-qualified, i.e., that include
/// "top-level" const.
///
/// Given
///   void a(int);
///   void b(int const);
///   void c(const int);
///   void d(const int*);
///   void e(int const) {};
/// Function(HasAnyParameter(HasType(IsConstQualified())))
///   matches "void b(int const)", "void c(const int)" and
///   "void e(int const) {}". It does not match d as there
///   is no top-level const on the parameter type "const int *".
inline internal::Matcher<clang::QualType> IsConstQualified() {
  return MakeMatcher(new internal::IsConstQualifiedMatcher());
}

/// Matches a member expression where the member is matched by a given matcher.
///
/// Given
///   struct { int first, second; } first, second;
///   int i(second.first);
///   int j(first.second);
/// MemberExpression(Member(HasName("first")))
///   matches second.first
///   but not first.second (because the member name there is "second").
AST_MATCHER_P(clang::MemberExpr, Member,
              internal::Matcher<clang::ValueDecl>, InnerMatcher) {
  return InnerMatcher.Matches(*Node.getMemberDecl(), Finder, Builder);
}

/// Matches a member expression where the object expression is matched by a
/// given matcher.
///
/// Given
///   struct X { int m; };
///   void f(X x) { x.m; m; }
/// MemberExpression(HasObjectExpression(HasType(Class(HasName("X")))))))
///   matches "x.m" and "m"
/// with HasObjectExpression(...)
///   matching "x" and the implicit object expression of "m" which has type X*.
AST_MATCHER_P(clang::MemberExpr, HasObjectExpression,
              internal::Matcher<clang::Expr>, InnerMatcher) {
  return InnerMatcher.Matches(*Node.getBase(), Finder, Builder);
}

/// Matches template instantiations of function, class, or static member
/// variable template instantiations.
///
/// Given
///   template <typename T> class X {}; class A {}; X<A> x;
/// or
///   template <typename T> class X {}; class A {}; template class X<A>;
/// Class(HasName("::X"), IsTemplateInstantiation())
///   matches the template instantiation of X<A>.
///
/// But given
///   template <typename T> class X {}; class A {};
///   template <> class X<A> {}; X<A> x;
/// Class(HasName("::X"), IsTemplateInstantiation())
///   does not match, as X<A> is an explicit template specialization.
inline internal::PolymorphicMatcherWithParam0<
  internal::IsTemplateInstantiationMatcher>
IsTemplateInstantiation() {
  return internal::PolymorphicMatcherWithParam0<
    internal::IsTemplateInstantiationMatcher>();
}

} // end namespace ast_matchers
} // end namespace clang

#endif // LLVM_CLANG_AST_MATCHERS_AST_MATCHERS_H
